// send.js â€” Ñ„Ñ€Ð¾Ð½Ñ‚ Ð´Ð»Ñ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²Ð¸Ñ‚ÐµÐ»Ñ Ñ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐºÐ¾Ð¹ ÐºÐ¾Ð¼Ð½Ð°Ñ‚Ñ‹ Ð² Ñ€ÐµÐ°Ð»ÑŒÐ½Ð¾Ð¼ Ð²Ñ€ÐµÐ¼ÐµÐ½Ð¸
const SOCKET_URL = 'https://twindrop.onrender.com';
const API_URL = SOCKET_URL + '/api'; // REST API
const socket = io(SOCKET_URL);

(function () {
    const codeInput = $('#codeInput');
    const joinBtn = $('#joinBtn');
    const sendUI = $('#sendUI');
    const fileInput = $('#file');
    const sendBtn = $('#sendBtn');
    const sendBar = $('#sendBar');
    const sendText = $('#sendText');
    const statusEl = $('#status');
    const qrContainer = $('#qrContainer'); // ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚ Ð´Ð»Ñ QR-ÐºÐ¾Ð´Ð°

    const q = parseQuery();
    if (q.room) {
        codeInput.value = q.room;
        // Ð¶Ð´Ñ‘Ð¼ Ð¿Ð¾ÐºÐ° input Ñ€ÐµÐ°Ð»ÑŒÐ½Ð¾ Ð¾Ð±Ð½Ð¾Ð²Ð¸Ñ‚ÑÑ Ð¸ ÑÑ€Ð°Ð·Ñƒ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼ ÐºÐ¾Ð¼Ð½Ð°Ñ‚Ñƒ
        setTimeout(async () => {
            await checkRoom(); // ÑÐ½Ð°Ñ‡Ð°Ð»Ð° Ð¿Ñ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼ Ñ‡ÐµÑ€ÐµÐ· API
            if (roomExists) join(); // ÐµÑÐ»Ð¸ ÐµÑÑ‚ÑŒ â€” ÑÑ€Ð°Ð·Ñƒ Ð¿Ð¾Ð´ÐºÐ»ÑŽÑ‡Ð°ÐµÐ¼ÑÑ
        }, 0);
    }

    let peer;
    let code;
    let roomExists = false; // Ñ…Ñ€Ð°Ð½ÐµÐ½Ð¸Ðµ ÑÑ‚Ð°Ñ‚ÑƒÑÐ°

    // ðŸ”Ž ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° ÐºÐ¾Ð¼Ð½Ð°Ñ‚Ñ‹ Ð² Ñ€ÐµÐ°Ð»ÑŒÐ½Ð¾Ð¼ Ð²Ñ€ÐµÐ¼ÐµÐ½Ð¸
    async function checkRoom() {
        const val = (codeInput.value || '').replace(/\D/g, '').padStart(6, '0');
        if (val.length !== 6) {
            setStatus(statusEl, 'Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ 6-Ð·Ð½Ð°Ñ‡Ð½Ñ‹Ð¹ ÐºÐ¾Ð´.');
            roomExists = false;
            joinBtn.disabled = true;
            return;
        }

        try {
            const res = await fetch(`${API_URL}/check-room/${val}`);
            const data = await res.json();

            if (data.exists) {
                setStatus(statusEl, 'ÐšÐ¾Ð¼Ð½Ð°Ñ‚Ð° Ð½Ð°Ð¹Ð´ÐµÐ½Ð°');
                roomExists = true;
                joinBtn.disabled = false;
            } else {
                setStatus(statusEl, 'ÐšÐ¾Ð¼Ð½Ð°Ñ‚Ð° Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½Ð°');
                roomExists = false;
                joinBtn.disabled = true;
            }
        } catch (err) {
            setStatus(statusEl, 'ÐžÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐºÐ¸ ÐºÐ¾Ð¼Ð½Ð°Ñ‚Ñ‹.');
            console.error(err);
            joinBtn.disabled = true;
            roomExists = false;
        }
    }

    // Ð¡Ð»ÑƒÑˆÐ°Ñ‚ÐµÐ»ÑŒ Ð´Ð»Ñ Ð²Ð²Ð¾Ð´Ð° ÐºÐ¾Ð´Ð° (Ñ€ÐµÐ°Ð»ÑŒÐ½Ð¾Ðµ Ð²Ñ€ÐµÐ¼Ñ)
    codeInput.addEventListener('input', checkRoom);

    function join() {
        // ÐµÑÐ»Ð¸ ÑƒÐ¶Ðµ ÐµÑÑ‚ÑŒ peer Ð¸Ð»Ð¸ Ð¼Ñ‹ ÑƒÐ¶Ðµ Ð² ÐºÐ¾Ð¼Ð½Ð°Ñ‚Ðµ â€” Ð²Ñ‹Ñ…Ð¾Ð´Ð¸Ð¼
        if (peer || socket.data?.joined) {
            setStatus(statusEl, 'Ð’Ñ‹ ÑƒÐ¶Ðµ Ð¿Ð¾Ð´ÐºÐ»ÑŽÑ‡ÐµÐ½Ñ‹.');
            return;
        }

        code = (codeInput.value || '').replace(/\D/g, '').padStart(6, '0');
        if (!roomExists) {
            setStatus(statusEl, 'Ð¡Ð½Ð°Ñ‡Ð°Ð»Ð° Ð²Ð²ÐµÐ´Ð¸Ñ‚Ðµ ÑÑƒÑ‰ÐµÑÑ‚Ð²ÑƒÑŽÑ‰Ð¸Ð¹ ÐºÐ¾Ð´.');
            return;
        }

        setStatus(statusEl, 'ÐŸÐ¾Ð´ÐºÐ»ÑŽÑ‡Ð°ÐµÐ¼ÑÑ Ðº ÐºÐ¾Ð¼Ð½Ð°Ñ‚Ðµâ€¦');
        socket.emit('join-room', { code });
        socket.data = { joined: true }; // ÑÑ‚Ð°Ð²Ð¸Ð¼ Ñ„Ð»Ð°Ð³
        joinBtn.disabled = true;        // Ð±Ð»Ð¾ÐºÐ¸Ñ€ÑƒÐµÐ¼ ÐºÐ½Ð¾Ð¿ÐºÑƒ
        joinBtn.textContent = 'ÐŸÐ¾Ð´ÐºÐ»ÑŽÑ‡ÐµÐ½Ð¾';
    }


    joinBtn.onclick = join;
    codeInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') join(); });

    // Ð¡Ð¾Ð±Ñ‹Ñ‚Ð¸Ñ Ð¾Ñ‚ ÑÐµÑ€Ð²ÐµÑ€Ð°
    socket.on('peer-joined', () => { /* Ð¿ÐµÑ€Ð²Ñ‹Ð¹ ÑƒÑ‡Ð°ÑÑ‚Ð½Ð¸Ðº Ð¸Ð³Ð½Ð¾Ñ€Ð¸Ñ€ÑƒÐµÑ‚ */ });

    socket.on('room-size', ({ size }) => {
        if (!code) return;
        if (size === 1) {
            setStatus(statusEl, 'ÐžÐ¶Ð¸Ð´Ð°Ð½Ð¸Ðµ Ð¿Ð¾Ð»ÑƒÑ‡Ð°Ñ‚ÐµÐ»Ñâ€¦');
        } else if (size === 2 && !peer) {
            setStatus(statusEl, 'ÐŸÐ¾Ð»ÑƒÑ‡Ð°Ñ‚ÐµÐ»ÑŒ Ð½Ð° Ð¼ÐµÑÑ‚Ðµ. Ð£ÑÑ‚Ð°Ð½Ð°Ð²Ð»Ð¸Ð²Ð°ÐµÐ¼ P2Pâ€¦');

            // ÑÐ¾Ð·Ð´Ð°Ñ‘Ð¼ P2P ÑÐ¾ÐµÐ´Ð¸Ð½ÐµÐ½Ð¸Ðµ
            peer = createPeer({
                initiator: true,
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' }
                ],
                onSignal: (data) => socket.emit('signal', { code, data }),
                onConnect: () => {
                    setStatus(statusEl, 'P2P ÑÐ¾ÐµÐ´Ð¸Ð½ÐµÐ½Ð¸Ðµ ÑƒÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½Ð¾. ÐœÐ¾Ð¶Ð½Ð¾ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²Ð»ÑÑ‚ÑŒ Ñ„Ð°Ð¹Ð».');
                    sendBtn.disabled = !fileInput.files?.length;
                },
                onData: () => { },
                onClose: () => setStatus(statusEl, 'Ð¡Ð¾ÐµÐ´Ð¸Ð½ÐµÐ½Ð¸Ðµ Ð·Ð°ÐºÑ€Ñ‹Ñ‚Ð¾.'),
                onError: (e) => setStatus(statusEl, 'ÐžÑˆÐ¸Ð±ÐºÐ° ÑÐ¾ÐµÐ´Ð¸Ð½ÐµÐ½Ð¸Ñ: ' + e?.message)
            });
            sendUI.style.display = 'block';
        }
    });

    socket.on('signal', (data) => { if (peer) peer.handleSignal(data); });
    socket.on('room-full', () => setStatus(statusEl, 'ÐšÐ¾Ð¼Ð½Ð°Ñ‚Ð° ÑƒÐ¶Ðµ Ð·Ð°Ð½ÑÑ‚Ð° Ð´Ð²ÑƒÐ¼Ñ ÑƒÑ‡Ð°ÑÑ‚Ð½Ð¸ÐºÐ°Ð¼Ð¸.'));

    // Ð£Ð¿Ñ€Ð°Ð²Ð»ÐµÐ½Ð¸Ðµ Ñ„Ð°Ð¹Ð»Ð¾Ð¼
    fileInput.addEventListener('change', () => {
        sendBtn.disabled = !(fileInput.files && fileInput.files.length);
    });

    sendBtn.onclick = async () => {
        if (!peer || !peer.channel() || peer.channel().readyState !== 'open') {
            setStatus(statusEl, 'ÐšÐ°Ð½Ð°Ð» ÐµÑ‰Ñ‘ Ð½Ðµ Ð³Ð¾Ñ‚Ð¾Ð².');
            return;
        }
        const file = fileInput.files[0];
        if (!file) return;

        peer.channel().send(JSON.stringify({ __meta: 'file', name: file.name, size: file.size }));

        const reader = file.stream().getReader();
        let sent = 0;

        setBar(sendBar, 0);
        sendText.textContent = `ÐžÑ‚Ð¿Ñ€Ð°Ð²ÐºÐ°: ${file.name}`;

        while (true) {
            const { value, done } = await reader.read();
            if (done) break;
            await waitForBufferLow(peer.channel());
            peer.channel().send(value.buffer);
            sent += value.byteLength;
            setBar(sendBar, sent / file.size);
            sendText.textContent = `${(sent / 1024 / 1024).toFixed(2)} / ${(file.size / 1024 / 1024).toFixed(2)} MB`;
        }

        setStatus(statusEl, 'Ð¤Ð°Ð¹Ð» Ð¾Ñ‚Ð¿Ñ€Ð°Ð²Ð»ÐµÐ½.');
    };

    function waitForBufferLow(dc) {
        return new Promise((resolve) => {
            const threshold = 1 * 1024 * 1024;
            if (dc.bufferedAmount < threshold) return resolve();
            const check = () => {
                if (dc.bufferedAmount < threshold) {
                    dc.removeEventListener('bufferedamountlow', check);
                    resolve();
                }
            };
            try { dc.bufferedAmountLowThreshold = threshold; } catch { }
            dc.addEventListener('bufferedamountlow', check);
            setTimeout(check, 50);
        });
    }
})();
